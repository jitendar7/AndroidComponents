Ref: http://www.androiddocs.com/guide/components/services.html#CreatingBoundService

Declare the services in manifest,
if restriction is required, set exported to 'false'
& services should be called by explicit intent , so do not declare intent filters

Two types of creating services  :
- IntentService
- extend Service class


//creating a a background service:
//Ref: https://developer.android.com/training/run-background-service/create-service

IntentService , has default worker thread that executes all intents,
It provides a straightforward structure for running an operation on a single background thread

a seperate work queue, default implementation of onBind(), onStartCommand()
never have to worry about multiple thread handling

class PullService: IntentService(PullService::class.simpleName){
override fun onHandleIntent(workIntent: Intent) {

    }
}

this also needs an entry in your application manifest


//sending work requests to the background service:
// Ref: https://developer.android.com/training/run-background-service/send-request
// Ref: https://developer.android.com/reference/androidx/core/app/JobIntentService

JobIntentService, create an intent and enqueue it to be executed by calling enqueueWork()

serviceIntent = Intent().apply{
    putExtra("download_url", dataUrl)
}

private const val RSS_JOB_ID = 1000
RSSPullService.enqueueWork(context,RSSPullService::class.java, RSS_JOB_ID, serviceIntent)


To report back the results, we can use the BroadcastReceiver (LocalBroadcastManager)

//Ref: https://developer.android.com/training/run-background-service/report-status
//Ref: https://stackoverflow.com/questions/53252792/what-are-differences-between-jobintentservice-and-intentservice


Report status from a JobIntentService,

val localIntent = Intent(BROADCAST_ACTION).apply {
    // put an extra
}
LocalBroadcastManager.getInstance(this).sendBroadcast(localIntent)


Receive status broadcasts from a JobIntentService,

private class DownloadStateReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent){
    ..
    }
}

In an activity
// The filter's action is BROADCAST_ACTION
        var statusIntentFilter = IntentFilter(BROADCAST_ACTION).apply {
            // Adds a data filter for the HTTP scheme
            addDataScheme("http")
        }

// Instantiates a new DownloadStateReceiver
        val downloadStateReceiver = DownloadStateReceiver()
        // Registers the DownloadStateReceiver and its intent filters
        LocalBroadcastManager.getInstance(this)
                .registerReceiver(downloadStateReceiver, statusIntentFilter)

A single BroadcastReceiver, can handle more than one type of broadcast Intent object,
each with its own action

/** Instantiates a new action filter.  No data filter is needed. */
        statusIntentFilter = IntentFilter(ACTION_ZOOM_IMAGE)
        // Registers the receiver with the new filter
        LocalBroadcastManager.getInstance(this)
                .registerReceiver(downloadStateReceiver, statusIntentFilter)

sending a broadcast intent doesn't start or resume an Activity. never start an activity in response to an incoming broadcast Intent


extend Service class implementation:

create HandlerThread in onCreate(),
HandlerThread thread = new HandlerThread("Service",Process.THREAD_PRIORITY_BACKGROUND)
thread.start();

get the looper from the HandlerThread
thread.getLooper()

attach the looper to the Handler
mServiceHandler = new ServiceHandler(mServiceLooper)

in method - onStartCommand(,,startId),
  create/obtain a Message from handler
  Message msg = mServiceHandler.obtainMessage()
  msg.arg1 = startId
  mServiceHandler.sendMessage(msg);


return START_STICKY , START_NOT_STICKY, START_REDELIVER_INTENT


If system kills the service after onStartCommand()

START_STICKY -> recreate the service, and call onStartCommand(), but do not deliver the last intent ,
                send null intent

START_NOT_STICKY -> do not recreate the service, unless there are pending intents to deliver

START_REDELIVER_INTENT -> recreate the service, with last intent that was delivered to the service


-> How to start a service
Intent intent = new Intent(this,HelloService.class)
startService(intent)

-> How to stop the service
stopself(int) / stopService()


-> Running a service in the Foreground
startForeground(ONGOING_NOTIFICATION_ID, notification)


Foreground services must show a status bar notification with a priority of PRIORITY_LOW or higher,
if the action is of low enough importance that you can use a minimum priority notification, instead of service, use
scheduled job.

Apps targeting Android 9 or higher and use foreground services, must request the permission
FOREGROUND_SERVICE (normal permission)


lifecycle:

startService():
onCreate() => onStartCommand() => service running => onDestroy()

bindService():
onCreate() => onBind() => client is bound to the service => onUnbind() => onDestroy()

Bound service: ( is the server in a client-server interface )
typically onUnbind(Intent i) returns boolean, false
otherwise the next client binds to the bound service, onRebind() called instead of onBind()

Bound Service:
Multiple clients can connect to the service at once. However the system calls your service's
onBind() method to retrieve the IBinder only when the first client binds. The system delivers the same
IBinder to any additional clients that bind, without calling onBind() again.

When the last client unBinds from the service, the system destroys the service

IBinder -> provides the programming interface that clients can use to interact
with the service

3 ways you can define the interface:

1. Extending the Binder class (service running in same process as client)
2. Using Messenger, work across difference processes, service defines Handler that responds to
different types of Message objects. ( Message objects is the key for communication )
Messenger queues all requests into a single thread.
3.AIDL (Android Interface Definition Language), performs all the work to decompose objects into
primitives, & marshall them across processes to perform IPC
If you want the service to handle multiple requests simultaneously, then you can use AIDL


Extending the Binder class:

Ref: https://android.googlesource.com/platform/development/+/master/samples/ApiDemos
Ref: https://developer.android.com/guide/components/bound-services

 - create instance of Binder, that does the following
    contains public methods that the client can call (or)
    returns the current service instance, which has public methods the client can call (or)
    returns an instance of another class hosted by the service with public methods the client can call.

 - return this in onBind()
 - in the client, receive Binder from the onServiceConnected() callback method


eg:
    class LocalService: Service() {

        // Binder given to clients
        private val binder = LocalBinder()

        // Random number generator
        private val mGenerator = Random()

        val randomNumber: Int
            get() = mGenerator.nextInt(100)

        inner class LocalBinder: Binder() {
            fun getService(): LocalService = this@LocalService
        }

        override fun onBind(intent: Intent): IBinder {
            return binder
        }
    }


class BindingActivity :Activity() {
    private lateinit var mService: LocalService
    private var mBound: Boolean = false

    private val connection = object: ServiceConnection{
        override fun onServiceConnected(){
            val binder = service as LocalService.LocalBinder
            mService = binder.getService()
            mBound = true
        }

        override fun onServiceDisconnected(arg0: ComponentName){
            mBound = false
        }
    }

    override fun onStart(){
        super.onStart()
        Intent(this, LocalService::class.java).also{intent ->
            bindService(intent, connection, Context.BIND_AUTO_CREATE)
        }
    }

    override fun onStop(){
        super.onStop()
        unbindService(connection)
    }

}
